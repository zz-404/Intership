pytorch 框架，基于python语言的深度学习框架

1. 类似于numpy的张量计算
2. 自动微分技术（结合BP）
3. 深度学习库
4. 动态计算图（边计算边生成）
5. GPU
6. 多种场景
7. 跨平台

w_new = w_old - α*梯度
学习率差不多是0.001-0.0001 学习率越小

# 张量创建
```python
# numpy 转换函数类型用astype

# numpy 等差数列 linspace

# python range random seed


"""
演示张量的基本创建方式

pytorch中的张量就是元素为同一种数据类型的多维矩阵，以类的形式封装
pytorch的张量具有GPU加速的能力
标量（0维张量） -> 只有一个值

图片 HWC

张量 -> 存储同一类型元素的容器，且元素值必须是数值才可以

张量的基本创建方式：
torch.tensor 根据指定数据创建张量
torch.Tensor 根据形状创建张量，其也可以用来创建指定数据的张量
torch.IntTensor,FloatTensor.DoubleTensor 创建指定类型的张量


"""

import torch
import numpy as np


# 1.定义函数，演示：torch.tensor 根据指定数据创建张量
def test01():
    # 1.标量，张量
    t1 = torch.tensor(10)
    print(f"t1:{t1},type:{type(t1)}")
    print('-' * 30)

    # 2.二维列表，张量
    data = [[1, 2, 3], [4, 5, 6]]
    t2 = torch.tensor(data)
    print(f"t2:{t2},type:{type(t2)}")

    # 3.numpy nd数组，张量
    data = np.random.randint(0, 10, size=(2, 3))
    t3 = torch.tensor(data, dtype=torch.float)  # 可以指定数据类型
    print(t3)

    # 4.尝试直接创建指定维度的张量

    # t4=torch.tensor(2,3)
    # print(f"t4:{t4},type:{type(t4)}")
    # TypeError: tensor() takes 1 positional argument but 2 were given

    # 小写是根据指定数据，大写均支持且可以直接创建指定维度的张量
    # t4 = torch.Tensor(2, 3)
    # print(t4)


# # torch.Tensor 根据形状创建张量，其也可以用来创建指定数据的张量
def test02():
    t1 = torch.Tensor(10)
    print(f"t1:{t1},type:{type(t1)}")
    print('-' * 30)

    data = [[1, 2, 3], [4, 5, 6]]
    t2 = torch.Tensor(data)
    print(f"t2:{t2},type:{type(t2)}")

    data = np.random.randint(0, 10, size=(2, 3))
    t3 = torch.Tensor(data)  # 大写Tensor，不可以指定数据类型
    print(t3)

    t4 = torch.Tensor(2, 3, 3)
    print(t4)



# torch.IntTensor,FloatTensor.DoubleTensor 创建指定类型的张量
def test03():
    # 1.标量，张量
    t1 = torch.IntTensor(10)
    print(f"t1:{t1},type:{type(t1)}")

    # 2.二维列表，张量
    data = [[1, 2, 3], [4, 5, 6]]
    t2 = torch.IntTensor(data)
    print(f"t2:{t2},type:{type(t2)}")

    # 3.numpy nd数组，张量
    data = np.random.randint(0, 10, size=(2, 3))
    t3 = torch.FloatTensor(data)  # 无法类型转换
    print(t3,type(t3))
    print("this ")
    print('-' * 30)

    # 如果类型不匹配，会尝试自动转换类型


test01()
test02()
test03()
# torch.float32 torch.int64 比较重要

# pytorch默认数据类型是float32（torch。floattensor）

```

# 创建指定值的张量
```
import numpy as np
import torch

# 创建0，1，指定值张量
"""
需要掌握的函数：

"""
# 123
 #alt shift ↓ 自动粘贴

# 1.torch.ones 和torch.ones_like
def test01():
    t1=torch.ones(2,3)
    print(t1)
    # t2=torch.ones_like([[1,2],[3,4],[5,6]]) 报错，input是tensor类型
    t2=torch.tensor([[1,2,3],[4,5,6],[7,8,9]])

    # 基于t2的形状创建全1张量
    t3=torch.ones_like(t2)
    print(t3)

# 2.torch.zeros 和torch.zeros_like
def test02():
    t1 = torch.zeros(2, 3)
    print(t1)

    t2 = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

    # 基于t2的形状创建全0张量
    t3 = torch.zeros_like(t2)
    print(t3)


# 3.torch.full 和torch.full_like
def test03():
    t1 = torch.full((2,3),255)
    print(t1)


    t2 = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

    # 基于t2的形状创建全255张量
    t3 = torch.full_like(t2,255)
    print(t3)

# 颜色越接近于0越黑

test01()
test02()
test03()
```
# 创建线性和随机张量
```

# torch.arange()和torch.linspace()创建线性张量
# torch.random.initial_seed()和torch,random.manual_seed

# ctrl alt insert 新建文件

"""

pytorch中创建线性和随机张量

torch.arange()和torch.linspace()创建线性张量
torch.random.initial_seed()和torch,random.manual_seed
torch.rand/randn() 创建随机浮点类型数量
torch.randint(low,high,size=()) 创建随机整数类型张量

需要掌握：
arange(),linspace(),manual_seed(),randint()
"""
import numpy as np
import torch
def test01():
    # 1.创建指定范围的线性张量
    t1=torch.arange(0,10,2) #包左不包右，步长
    # 注意不要写range，UserWarning: torch.range is deprecated and will be removed in a future release because its behavior is inconsistent with Python's range builtin.
    print(t1,type(t1))

    # 创建等差数列
    t2=torch.linspace(1,10,5) #包左又包右，元素的个数
    print(t2,type(t2))


def test02():
    # step1 设置随机种子
    torch.initial_seed() # 默认采用当前系统的时间戳作为随机种子，不可复现（不用）
    torch.manual_seed(2) # 设置随机种子，每次数据都不变,下面所有的数据都要用，所以一般放在导包下面

    # step2 创建随机张量
    # 0-1均匀分布
    t1=torch.rand((2,3))
    print(t1,type(t1))

    # 符合正态分布的随机张量
    t2=torch.randn((2,3))
    print(t2,type(t2))

    # 创建随机整数张量
    t2=torch.randint(0,10,size=(2,3))
    arr=np.random.randint(0,19,size=(3,5)) # numpy中的用法
    print(t2,type(t2))
    print(arr,type(arr))

test01()
test02()
```

# 张量数据类型转化
```python
"""
张量元素类型转换
data.type 推荐
data.half/double/float(不推荐)
"""
import torch

t1=torch.tensor([1,2,3,4,5])
print(t1,t1.dtype)  # 数据类型：.dtype()函数

# 用dtype在创建时直接指定类型
t1=torch.tensor([1,2,3,4,5],dtype=torch.double) # 默认·float32

# 掌握：type
t2=t1.type(torch.int16)  #注意一定是torch.int16不是int16
print(t2,t2.dtype)
t2=t2.type(torch.float32)  #注意一定是torch.int16不是int16
print(t2,t2.dtype)
```

# 张量的类型转化
```
import numpy as np
import torch
from sympy.stats.sampling.sample_numpy import numpy
"""
张量->numpy
    张量对象.numpy() 共享内存
    张量对象.numpy().copy()  不共享内存，链式编程写法

numpy->张量
    torch.tensor(nd数组) 不共享内存
    torch.from_numpy()  共享内存
    
标量提取，张量对象.item()
"""

def test01():
    t1=torch.tensor([1,2,3,4,5])
    n1=t1.numpy() # 共享内存,直接给地址，指向同一份内存
    print(n1,type(n1))
    print(t1,type(t1))
    n1[0]=100
    print(t1, type(t1))

    n2=t1.numpy().copy() #重新申请一块内存，只更改数据
    n2[0]=1000
    print(t1,type(t1))


def test02():
    n1=numpy.array([[1,2,3],[4,5,6],[7,8,9]])
    print(n1,type(n1))
    t1=torch.tensor(n1)
    print(t1,type(t1))
    t2=torch.from_numpy(n1)

    n1[0]=100
    print(n1,type(n1))
    print(t1,type(t1))
    t2=t2.type(torch.float32)
    print(t2,type(t2))

def test03():
    t1=torch.tensor(100)
    # t1 = torch.tensor("123") 不可，张量中只能是数值不能是字符串
    data=t1.item()
    return data
# data1=torch.tensor()
if __name__=='__main__':
    test01()
    test02()
    print(test03(),type(test03()))
```

# 张量的基本运算
```
"""

add, sub,mul,div,neg  加减乘除取反
add_,sub_,mul_,div_,neg_ 功能同上，只不过可以修改原数据，类似于pandas的inplace=ture

需要记忆：
1. 符号替代
    + - * / // **
    += -= *= /= //= **=
2. 张量和数值运算，则该数值和张量中的每个值运算
"""
import numpy as np
import torch
def test01():
    t1=torch.tensor([1,2,3])

    t2=t1.add(10)
    print(t1) # 不修改原数据
    t1=t1+10
    print(t1)
    t1+=10
    print(t1)
    t1*=2 # 每个元素都相乘
    print(t1)
    t1//=3
    print(t1)
    t1**=2
    print(t1)
    print(t2)


"""
点乘和矩阵相乘

点乘：
对应位置的元素相乘
点乘就是* 
维度需要一致

矩阵相乘：
m1 shape: a*b  
m2 shape: b*c
res shape a*c

两种方法：
1. @
2.torch.matmul(matrix multiply) 
对于输入的shape不同的张量，对应的最后两位必须符合矩阵运算规则

numpy 中的矩阵乘法:dot
"""

def test02():
    t1=torch.tensor(
        [
            [1,2,3,4],
            [2,3,4,5]
        ]
    )

    t2=torch.tensor(
        [
            [1,2,3,4],
            [2,3,4,5]
        ]
    )

    t3=torch.tensor(
        [
            [1,2],
            [3,4],
            [5,6],
            [7,8],
        ]
    )

    print(t1*t2) #注意如果想做点乘，行列数必须保持一致
    print(t1.mul(t2))

    print(t1@t3)
    print(t1.matmul(t3))
    t4=t1@t3 #可以直接赋值的
    print(t4)


"""
张量运算函数
sum,max,min,mean ->都有dim参数，dim等于几，那个索引的维度就要消失
pow,sqrt(**=1/2),exp,log,log2,log10  ->没有dim参数

需要掌握
sum,max,min,mean,pow

"""

def test03():
    t1=torch.tensor(
        [
            [1,2,3,4],
            [5,6,7,8],
            [9,10,11,12],
        ]
        ,dtype=torch.float
    )

    # 演示有dim参数的函数
    print(t1.sum(dim=0))
    print(t1.sum(dim=1))
    print(t1.sum()) #不写，全局求和

    print(t1.max(dim=0))
    print(t1.max(dim=1))
    print(t1.max())

    # mean 不能直接处理非float类型的数据
    print(t1.mean(dim=0))
    print(t1.mean(dim=1))
    print(t1.mean())


    # 演示没有dim参数的函数
    print(t1.pow(2))
    print(t1**(1/2)) #注意加括号，**优先级没那么高
    print(t1.log())

if __name__ == '__main__':
    test01()
    test02()
    test03()
```
# 张量的索引
```
import torch
"""
简单行列索引 
列表索引 
范围索引 
布尔索引
多维索引

掌握：
    简单行列索引，范围索引，多维索引
"""

# 1.设置随机种子
torch.manual_seed(24)

t1=torch.randint(0,10,(5,5))
print(t1)
print("_"*30)


# 简单行列索引
# 获取第二行的所有数据
print(t1[1])
print(t1[1,:]) #效果同上
print(t1[:,2]) #获取第三列所有数据



# 列表索引
# 前边的表示行，后面的表示列

# 返回（0，1），（1，2）位置的元素
print(t1[[0,1],[1,2]])
# 返回（1，2），（3，4）位置的元素
print(t1[[1,3],[2,4]])

# 获取第0，1行，第1，2，所有元素
print(t1[[0,1],[[1],[2]]]) #又套了一层括号表示一对二



# 范围索引

# 前三行前两列
print(t1[:3,:2])

# 前两列
print(t1[:,:2])

# 所有奇数行所有偶数列
print(t1[1::2,::2]) # 始终记好：起始，终止，步长



# 布尔写法
print(t1[torch.tensor([True,False,False,True,True]),:]) # 演示布尔写法

# 找第二行大于5的列索引，在找这些列的所有数据
print(t1[:,t1[1,:]>5]) #这里的t1[1,:]>5返回一些列索引
print(t1[1,t1[1,:]>5])


# 多维索引
t1=torch.randint(0,10,(2,3,4))
print(t1)

# 需求一，获取0轴上的第一个数据
print(t1[0,:,:])

# 获取1轴上的第一个数据
print(t1[:,0,:])

# 获取2轴上的第一个数据
print(t1[:,:,0])
```

# 张量的形状操作
```
"""

reshape()
squeze()
unsqueeze()
permute()
view()
contiguous()

"""

import torch

torch.manual_seed(24)

# reshape函数可以在保持张量数据不变的前提下，改变数据的维度
# 必须满足元素个数相等，并且按顺序填写
# reshape函数把t1 -> 3*2 ,1*6,6*1
def test01():
    t1=torch.randint(0,10,(2,3))
    print(f"t1={t1},shape={t1.shape},row: {t1.shape[0]},col: {t1.shape[1],t1.shape[-1]}") #注意打印的是shape
    t2=t1.reshape(3,2)
    print(t2)
    t2=t1.reshape(1,6)
    print(t2)
    t2=t1.reshape(6,1)
    print(t2)

    # t2=t1.reshape(2.5)  # 报错，元素值大于原来的元素


# squeeze函数删除所有为1的维度(降维)，unsqueeze()在指定的轴上增加一个1维度(升维)
"""
模型欠拟合要升维，模型过拟合要降维
"""
def test02():

    t1=torch.randint(0,10,(2,3))
    print(t1)

    t2=t1.unsqueeze(0) #在当前数字之前（0轴）上添加一个维度
    print(t2,t2.shape)

    t2=t1.unsqueeze(1)
    print(t2,t2.shape)

    t2 = t1.unsqueeze(2)
    print(t2, t2.shape)

    # t2=t1.unsqueeze(3)
    # print(t2, t2.shape)  不能做，只能限制在原来维度数+1，维度越界了

    t2=torch.randint(0,10,(2,1,3,1,1))
    print(t2)
    t2=t2.squeeze() #squeeze
    print(t2, t2.shape)
test02()
```
